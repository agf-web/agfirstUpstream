--- src/SchedulerManager.php
+++ src/SchedulerManager.php
@@ -4,9 +4,10 @@ namespace Drupal\scheduler;
 
 use Drupal\Core\Config\ConfigFactory;
 use Drupal\Core\Datetime\DateFormatter;
-use Drupal\Core\Entity\EntityManager;
-use Drupal\Core\Url;
+use Drupal\Core\Entity\EntityFieldManagerInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
 use Drupal\Core\Extension\ModuleHandler;
+use Drupal\Core\Url;
 use Drupal\node\Entity\Node;
 use Drupal\node\NodeInterface;
 use Drupal\scheduler\Exception\SchedulerMissingDateException;
@@ -40,11 +41,25 @@ class SchedulerManager {
   protected $moduleHandler;
 
   /**
-   * Entity Manager service object.
+   * The scheduler_content_moderation_integration module status.
+   *
+   * @var boolean
+   */
+  protected $schedulerModerationEnabled;
+
+  /**
+   * The entity field manager.
    *
-   * @var \Drupal\Core\Entity\EntityManager
+   * @var \Drupal\Core\Entity\EntityFieldManagerInterface
    */
-  protected $entityManager;
+  protected $entityFieldManager;
+
+  /**
+   * The entity type manager.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
 
   /**
    * Config Factory service object.
@@ -56,12 +71,14 @@ class SchedulerManager {
   /**
    * Constructs a SchedulerManager object.
    */
-  public function __construct(DateFormatter $dateFormatter, LoggerInterface $logger, ModuleHandler $moduleHandler, EntityManager $entityManager, ConfigFactory $configFactory) {
+  public function __construct(DateFormatter $dateFormatter, LoggerInterface $logger, ModuleHandler $moduleHandler, EntityTypeManagerInterface $entityTypeManager, ConfigFactory $configFactory, EntityFieldManagerInterface $entityFieldManager) {
     $this->dateFormatter = $dateFormatter;
     $this->logger = $logger;
     $this->moduleHandler = $moduleHandler;
-    $this->entityManager = $entityManager;
+    $this->entityTypeManager = $entityTypeManager;
     $this->configFactory = $configFactory;
+    $this->entityFieldManager = $entityFieldManager;
+    $this->schedulerModerationEnabled = $this->moduleHandler->moduleExists('scheduler_content_moderation_integration');
   }
 
   /**
@@ -87,12 +104,11 @@ class SchedulerManager {
     $nids = [];
     $scheduler_enabled_types = array_keys(_scheduler_get_scheduler_enabled_node_types($action));
     if (!empty($scheduler_enabled_types)) {
-      // @TODO: \Drupal calls should be avoided in classes.
-      // Replace \Drupal::entityQuery with dependency injection?
-      $query = \Drupal::entityQuery('node')
+      $query = $this->entityTypeManager->getStorage('node')->getQuery()
         ->exists('publish_on')
         ->condition('publish_on', REQUEST_TIME, '<=')
         ->condition('type', $scheduler_enabled_types, 'IN')
+        ->latestRevision()
         ->sort('publish_on')
         ->sort('nid');
       // Disable access checks for this query.
@@ -111,9 +127,7 @@ class SchedulerManager {
     // unlike 7.x where each translation was a separate node. This means that
     // the list of node ids returned above may have some translations that need
     // processing now and others that do not.
-    $nodes = Node::loadMultiple($nids);
-    // @TODO: Node::loadMultiple calls should be avoided in classes.
-    // Replace with dependency injection?
+    $nodes = $this->loadNodes($nids);
     foreach ($nodes as $node_multilingual) {
 
       // The API calls could return nodes of types which are not enabled for
@@ -146,7 +160,7 @@ class SchedulerManager {
         // @TODO This will now never be thrown due to the empty(publish_on)
         // check above to cater for translations. Remove this exception?
         if (empty($node->publish_on->value)) {
-          $field_definitions = $this->entityManager->getFieldDefinitions('node', $node->getType());
+          $field_definitions = $this->entityFieldManager->getFieldDefinitions('node', $node->getType());
           $field = (string) $field_definitions['publish_on']->getLabel();
           throw new SchedulerMissingDateException(sprintf("Node %d '%s' will not be published because field '%s' has no value", $node->id(), $node->getTitle(), $field));
         }
@@ -193,13 +207,21 @@ class SchedulerManager {
         $this->logger->notice('@type: scheduled publishing of %title.', $logger_variables);
 
         // Use the actions system to publish the node.
-        $this->entityManager->getStorage('action')->load('node_publish_action')->getPlugin()->execute($node);
+        $this->entityTypeManager->getStorage('action')->load('node_publish_action')->getPlugin()->execute($node);
 
         // Invoke the event to tell Rules that Scheduler has published the node.
         if ($this->moduleHandler->moduleExists('scheduler_rules_integration')) {
           _scheduler_rules_integration_dispatch_cron_event($node, 'publish');
         }
 
+        // If scheduler_content_moderation_integration is enabled, set to
+        // published state.
+        if ($this->schedulerModerationEnabled && $node->get('moderation_state')) {
+          $state = $node->publish_state->value;
+          $node->set('moderation_state', $state);
+          $node->publish_state->value = NULL;
+        }
+
         // Trigger the PUBLISH event so that modules can react after the node is
         // published.
         $event = new SchedulerEvent($node);
@@ -236,12 +258,11 @@ class SchedulerManager {
     $nids = [];
     $scheduler_enabled_types = array_keys(_scheduler_get_scheduler_enabled_node_types($action));
     if (!empty($scheduler_enabled_types)) {
-      // @TODO: \Drupal calls should be avoided in classes.
-      // Replace \Drupal::entityQuery with dependency injection?
-      $query = \Drupal::entityQuery('node')
+      $query = $this->entityTypeManager->getStorage('node')->getQuery()
         ->exists('unpublish_on')
         ->condition('unpublish_on', REQUEST_TIME, '<=')
         ->condition('type', $scheduler_enabled_types, 'IN')
+        ->latestRevision()
         ->sort('unpublish_on')
         ->sort('nid');
       // Disable access checks for this query.
@@ -256,9 +277,7 @@ class SchedulerManager {
     // Allow other modules to alter the list of nodes to be unpublished.
     $this->moduleHandler->alter('scheduler_nid_list', $nids, $action);
 
-    // @TODO: Node::loadMultiple calls should be avoided in classes.
-    // Replace with dependency injection?
-    $nodes = Node::loadMultiple($nids);
+    $nodes = $this->loadNodes($nids);
     foreach ($nodes as $node_multilingual) {
       // The API calls could return nodes of types which are not enabled for
       // scheduled unpublishing. Do not process these.
@@ -298,7 +317,7 @@ class SchedulerManager {
         // @TODO This will now never be thrown due to the empty(unpublish_on)
         // check above to cater for translations. Remove this exception?
         if (empty($unpublish_on)) {
-          $field_definitions = $this->entityManager->getFieldDefinitions('node', $node->getType());
+          $field_definitions = $this->entityFieldManager->getFieldDefinitions('node', $node->getType());
           $field = (string) $field_definitions['unpublish_on']->getLabel();
           throw new SchedulerMissingDateException(sprintf("Node %d '%s' will not be unpublished because field '%s' has no value", $node->id(), $node->getTitle(), $field));
         }
@@ -342,13 +361,20 @@ class SchedulerManager {
         $this->logger->notice('@type: scheduled unpublishing of %title.', $logger_variables);
 
         // Use the actions system to publish the node.
-        $this->entityManager->getStorage('action')->load('node_unpublish_action')->getPlugin()->execute($node);
+        $this->entityTypeManager->getStorage('action')->load('node_unpublish_action')->getPlugin()->execute($node);
 
         // Invoke event to tell Rules that Scheduler has unpublished this node.
         if ($this->moduleHandler->moduleExists('scheduler_rules_integration')) {
           _scheduler_rules_integration_dispatch_cron_event($node, 'unpublish');
         }
 
+        // If scheduler_content_moderation_integration is enabled, set to published state.
+        if ($this->schedulerModerationEnabled && $node->get('moderation_state')){
+          $state = $node->unpublish_state->value;
+          $node->set('moderation_state', $state);
+          $node->unpublish_state->value = NULL;
+        }
+
         // Trigger the UNPUBLISH event so that modules can react before the node
         // is unpublished.
         $event = new SchedulerEvent($node);
